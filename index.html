<!DOCTYPE html>
<html>
  <head>
    <title>NOOTY BIRD</title>
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #70c5ce;
        touch-action: manipulation;
      }
      #gameCanvas {
        display: block;
        margin: 0 auto;
        background-color: #70c5ce;
      }
      #scoreDisplay {
        position: absolute;
        top: 20px;
        width: 100%;
        text-align: center;
        font-family: "Helvetica", sans-serif;
        font-size: 2vw;
        color: white;
        text-shadow: 2px 2px 4px #000;
        z-index: 1;
        display: none;
      }
    </style>
  </head>
  <body>
    <canvas id="gameCanvas"></canvas>
    <div id="scoreDisplay">Score: 0 | High Score: 0</div>
    <script>
      // Get the canvas element and context
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");

      // Game object to hold all game-related variables and states
      const game = {
        gravity: 1500,
        flapStrength: -400,
        pipeWidth: 0,
        initialPipeGap: 0,
        pipeGap: 0,
        minPipeGap: 0,
        birdSize: 0,
        pipeInterval: 2000,
        bird: {},
        pipes: [],
        clouds: [],
        particles: [],
        groundCreatures: [],
        backgroundLayers: [],
        score: 0,
        highScore: localStorage.getItem("highScore") || 0,
        lastPipeTime: 0,
        isGameOver: false,
        isGameStarted: false,
        isPaused: false,
        backgroundX: 0,
        lastCloudTime: 0,
        maxPipeHeight: 0,
        minPipeHeight: 0,
        groundHeight: 0,
        groundX: 0,
        wingAngle: 0,
        wingDirection: 1,
        catAdded: false,
        frogAdded: false,
        // Variables for background management
        timeOfDay: parseFloat(localStorage.getItem("timeOfDay")) || 1.0,
        timeOfDayVar: 1,
        backgrounds: [],
        // Time management
        lastFrameTime: 0,
        // Stars for night sky
        stars: [],
        // Shooting star for easter egg
        shootingStar: null,
        // UFO easter egg
        ufo: null,
        // Pipe speed variables
        initialPipeSpeed: 200,
        pipeSpeed: 200,
        maxPipeSpeed: 300,
        // Pipe gap sizes
        pipeGapSizes: [],
        pipeGapIndex: 0,
      };

      // Responsive canvas size
      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        initializeGameSettings();
        if (game.isGameStarted) {
          // Adjust bird position and size on resize
          game.bird.x = canvas.width / 4;
          game.bird.width = game.birdSize;
          game.bird.height = game.birdSize;
        } else {
          drawIntroScreen();
        }
      }
      window.addEventListener("resize", resizeCanvas);
      resizeCanvas();

      // Initialize game settings based on canvas size
      function initializeGameSettings() {
        // Adjusted gravity and flap strength for deltaTime
        game.gravity = 1500;
        game.flapStrength = -400;

        game.pipeWidth = canvas.width * 0.1;
        game.initialPipeGap = canvas.height * 0.28;
        // Pipe gap sizes
        game.pipeGapSizes = [
          canvas.height * 0.28, // Largest gap
          canvas.height * 0.24,
          canvas.height * 0.2,
          canvas.height * 0.18,
          canvas.height * 0.16, // Smallest gap
        ];
        game.pipeGapIndex = 0;
        game.pipeGap = game.pipeGapSizes[game.pipeGapIndex];

        game.birdSize = canvas.height * 0.05;
        game.maxPipeHeight = canvas.height - game.pipeGap - canvas.height * 0.1;
        game.minPipeHeight = canvas.height * 0.1;
        game.groundHeight = canvas.height * 0.1;
        game.groundX = 0;

        // Initialize background layers for parallax
        game.backgroundLayers = [
          { x: 0, speed: 30, draw: drawBackgroundLayer1 },
          { x: 0, speed: 60, draw: drawBackgroundLayer2 },
        ];

        // Initialize backgrounds
        initializeBackgrounds();

        // Initialize stars for night sky
        initializeStars();

        // Initialize pipe speed
        game.initialPipeSpeed = 200;
        game.pipeSpeed = game.initialPipeSpeed;
        game.maxPipeSpeed = 300;
      }

      // Initialize backgrounds
      function initializeBackgrounds() {
        game.backgrounds = [
          // 1-15 Sunrise
          { type: "sunrise", color: "#FF4500" }, // 1-15
          // 16-25 Daytime
          { type: "day", color: "#87CEEB" }, // 16-25
          // 26-45 Nighttime
          { type: "night", color: "#191970" }, // 26-45
          // 46-55 Sunset
          { type: "sunrise", color: "#FF6347" }, // 46-55
        ];
      }

      // Initialize stars for night sky
      function initializeStars() {
        game.stars = [];
        for (let i = 0; i < 100; i++) {
          game.stars.push({
            x: Math.random() * canvas.width,
            y: (Math.random() * canvas.height) / 2,
            size: Math.random() * 2 + 1,
            twinkle: Math.random() * 0.5 + 0.5,
          });
        }
      }

      // Event listeners
      document.addEventListener("keydown", handleKeyDown);
      document.addEventListener("touchstart", handleTouchStart, {
        passive: false,
      });

      function handleKeyDown(e) {
        if (e.code === "Space") {
          e.preventDefault();
          if (game.isGameOver) {
            resetGame();
          } else if (!game.isGameStarted) {
            startGame();
          } else if (!game.isPaused) {
            game.bird.velocity = game.flapStrength;
            createParticles();
          }
        }
        if (e.code === "KeyP") {
          if (game.isGameStarted && !game.isGameOver) {
            game.isPaused = !game.isPaused;
            if (game.isPaused) {
              drawPauseScreen();
            } else {
              game.lastFrameTime = performance.now();
              gameLoop(game.lastFrameTime);
            }
          }
        }
      }

      function handleTouchStart(e) {
        e.preventDefault();
        if (game.isGameOver) {
          resetGame();
        } else if (!game.isGameStarted) {
          startGame();
        } else if (!game.isPaused) {
          game.bird.velocity = game.flapStrength;
          createParticles();
        }
      }

      // Start the game
      function startGame() {
        if (!game.isGameStarted) {
          game.isGameStarted = true;
          game.lastPipeTime = Date.now();
          game.lastCloudTime = Date.now();
          game.lastFrameTime = performance.now();
          document.getElementById("scoreDisplay").style.display = "block";
          updateScoreDisplay();
          gameLoop(game.lastFrameTime);
        }
      }

      // Reset the game to initial state
      function resetGame() {
        initializeGameSettings();
        game.bird = {
          x: canvas.width / 4,
          y: canvas.height / 2,
          width: game.birdSize,
          height: game.birdSize,
          velocity: 0,
          angle: 0,
        };
        game.wingAngle = 0;
        game.wingDirection = 1;
        game.pipes = [];
        game.clouds = [];
        game.particles = [];
        game.groundCreatures = [];
        game.score = 0;
        game.isGameOver = false;
        game.isGameStarted = false;
        game.isPaused = false;
        game.backgroundX = 0;
        game.lastCloudTime = Date.now();
        game.lastPipeTime = Date.now();
        game.highScore = localStorage.getItem("highScore") || 0;
        game.catAdded = false;
        game.frogAdded = false;
        game.shootingStar = null; // Reset shooting star
        game.ufo = null; // Reset UFO
        document.getElementById("scoreDisplay").style.display = "none";
        drawIntroScreen();
      }

      // Update the score display
      function updateScoreDisplay() {
        const scoreDisplay = document.getElementById("scoreDisplay");
        if (scoreDisplay) {
          scoreDisplay.innerText = `Score: ${game.score} | High Score: ${game.highScore}`;
        }
      }

      // Game loop
      function gameLoop(currentTime) {
        if (!game.lastFrameTime) {
          game.lastFrameTime = currentTime;
        }
        let deltaTime = (currentTime - game.lastFrameTime) / 1000; // deltaTime in seconds
        deltaTime = Math.min(deltaTime, 0.1); // Cap deltaTime to prevent big jumps
        game.lastFrameTime = currentTime;

        if (!game.isGameOver && !game.isPaused) {
          requestAnimationFrame(gameLoop);

          // Clear canvas
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          // Update bird
          game.bird.velocity += game.gravity * deltaTime;
          game.bird.y += game.bird.velocity * deltaTime;

          // Rotate bird based on velocity
          game.bird.angle = Math.min(
            Math.PI / 4,
            Math.max(-Math.PI / 4, game.bird.velocity / 300)
          );

          // Update wing angle for flapping animation
          game.wingAngle += 4 * game.wingDirection * deltaTime;
          if (game.wingAngle > 0.5 || game.wingAngle < -0.5) {
            game.wingDirection *= -1;
          }

          // Update time of day smoothly
          game.timeOfDay += deltaTime * 0.5; // Adjust speed as needed
          if (game.timeOfDay > 55) {
            game.timeOfDay = 1;
          }
          game.timeOfDayVar = Math.floor(game.timeOfDay);
          localStorage.setItem("timeOfDay", game.timeOfDay);

          // Draw background
          drawBackground(deltaTime);

          // Draw clouds
          drawClouds(deltaTime);

          // Draw background layers for parallax effect
          drawParallaxBackground(deltaTime);

          // Draw ground
          drawGround(deltaTime);

          // Add ground creatures based on score
          addGroundCreatures();

          // Update and draw ground creatures
          updateGroundCreatures(deltaTime);

          // Draw pipes
          updatePipes(deltaTime);

          // Check collisions
          checkCollisions();

          // Draw bird
          drawBird();

          // Update and draw particles
          updateParticles(deltaTime);

          // Update score
          updateScoreDisplay();

          // Increase difficulty
          increaseDifficulty();

          // Add clouds at intervals
          let now = Date.now();
          if (now - game.lastCloudTime > 3000) {
            addCloud();
            game.lastCloudTime = now;
          }
        } else if (game.isPaused) {
          drawPauseScreen();
        } else {
          // Game over screen
          drawGameOverScreen();
        }
      }

      // Draw the background
      function drawBackground(deltaTime) {
        // Get current background
        const currentBackground = getCurrentBackground();
        ctx.fillStyle = currentBackground.color;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Calculate celestial body's position based on timeOfDay
        let celestialX;
        let celestialY = canvas.height * 0.2; // Adjust Y position if needed

        if (
          currentBackground.type === "sunrise" ||
          currentBackground.type === "day"
        ) {
          // Sun
          if (game.timeOfDay >= 1 && game.timeOfDay <= 25) {
            // Sunrise and daytime
            celestialX = ((game.timeOfDay - 1) / (25 - 1)) * canvas.width;
          } else if (game.timeOfDay >= 46 && game.timeOfDay <= 55) {
            // Second sunrise
            celestialX = ((game.timeOfDay - 46) / (55 - 46)) * canvas.width;
          } else {
            celestialX = 0; // Default position
          }

          // Change sun color based on time of day
          let sunColor;
          if (
            (game.timeOfDay >= 1 && game.timeOfDay <= 15) ||
            (game.timeOfDay >= 46 && game.timeOfDay <= 55)
          ) {
            // Sunrise
            sunColor = "orange";
          } else if (game.timeOfDay >= 16 && game.timeOfDay <= 25) {
            // Daytime
            sunColor = "yellow";
          } else {
            sunColor = "yellow"; // Default color
          }

          ctx.fillStyle = sunColor;
          ctx.beginPath();
          ctx.arc(celestialX, celestialY, 50, 0, 2 * Math.PI);
          ctx.fill();

          // Draw sun rays
          drawSunRays(celestialX, celestialY);
        } else if (currentBackground.type === "night") {
          // Moon
          if (game.timeOfDay >= 26 && game.timeOfDay <= 45) {
            celestialX = ((game.timeOfDay - 26) / (45 - 26)) * canvas.width;
          } else {
            celestialX = 0; // Default position
          }

          // Draw the moon
          drawMoon(celestialX, celestialY);

          // Add stars
          drawStars();

          // Possibly add shooting star
          handleShootingStar();

          // Possibly add UFO
          handleUFO(deltaTime);
        }
      }

      // Draw sun rays
      function drawSunRays(x, y) {
        ctx.strokeStyle = "rgba(255, 215, 0, 0.5)"; // Golden color with transparency
        ctx.lineWidth = 2;
        const numRays = 12;
        const radius = 60;
        for (let i = 0; i < numRays; i++) {
          const angle = (i / numRays) * Math.PI * 2;
          const x1 = x + Math.cos(angle) * 50;
          const y1 = y + Math.sin(angle) * 50;
          const x2 = x + Math.cos(angle) * radius;
          const y2 = y + Math.sin(angle) * radius;
          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
          ctx.stroke();
        }
      }

      // Draw the moon with craters
      function drawMoon(x, y) {
        ctx.fillStyle = "white";
        ctx.beginPath();
        ctx.arc(x, y, 40, 0, 2 * Math.PI);
        ctx.fill();

        // Draw static craters
        ctx.fillStyle = "#D3D3D3"; // Light gray for craters
        const craters = [
          { xOffset: -15, yOffset: -10, radius: 6 },
          { xOffset: 10, yOffset: -15, radius: 4 },
          { xOffset: -5, yOffset: 5, radius: 8 },
          { xOffset: 15, yOffset: 10, radius: 5 },
          { xOffset: -10, yOffset: 15, radius: 3 },
        ];
        craters.forEach((crater) => {
          ctx.beginPath();
          ctx.arc(
            x + crater.xOffset,
            y + crater.yOffset,
            crater.radius,
            0,
            2 * Math.PI
          );
          ctx.fill();
        });
      }

      // Get current background based on timeOfDayVar
      function getCurrentBackground() {
        let timeOfDayVar = game.timeOfDayVar;
        if (timeOfDayVar >= 1 && timeOfDayVar <= 15) {
          return game.backgrounds[0]; // Sunrise
        } else if (timeOfDayVar >= 16 && timeOfDayVar <= 25) {
          return game.backgrounds[1]; // Daytime
        } else if (timeOfDayVar >= 26 && timeOfDayVar <= 45) {
          return game.backgrounds[2]; // Nighttime
        } else if (timeOfDayVar >= 46 && timeOfDayVar <= 55) {
          return game.backgrounds[3]; // Sunrise
        } else {
          // Reset to sunrise if out of range
          game.timeOfDay = 1;
          game.timeOfDayVar = 1;
          return game.backgrounds[0];
        }
      }

      // Draw stars at night
      function drawStars() {
        ctx.fillStyle = "white";
        for (let i = 0; i < game.stars.length; i++) {
          const star = game.stars[i];
          ctx.globalAlpha = star.twinkle;
          ctx.fillRect(star.x, star.y, star.size, star.size);
        }
        ctx.globalAlpha = 1;
      }

      // Handle shooting star (easter egg)
      function handleShootingStar() {
        // Randomly create a shooting star
        if (!game.shootingStar && Math.random() < 0.001) {
          game.shootingStar = {
            x: Math.random() * canvas.width * 0.5,
            y: Math.random() * canvas.height * 0.5,
            length: 100,
            speedX: Math.random() * 300 + 200,
            speedY: Math.random() * 100 + 50,
            life: 0.5, // seconds
          };
        }

        // Update and draw shooting star
        if (game.shootingStar) {
          const ss = game.shootingStar;
          ss.x += ss.speedX * (1 / 60);
          ss.y += ss.speedY * (1 / 60);
          ss.life -= 1 / 60;
          ctx.strokeStyle = "white";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(ss.x, ss.y);
          ctx.lineTo(
            ss.x - ss.length,
            ss.y - ss.length * (ss.speedY / ss.speedX)
          );
          ctx.stroke();
          if (ss.life <= 0) {
            game.shootingStar = null;
          }
        }
      }

      // Handle UFO (new easter egg)
      function handleUFO(deltaTime) {
        // Randomly create a UFO
        if (!game.ufo && Math.random() < 0.0005) {
          game.ufo = {
            x: -100,
            y: Math.random() * canvas.height * 0.3,
            speed: 200 + Math.random() * 100,
          };
        }

        // Update and draw UFO
        if (game.ufo) {
          game.ufo.x += game.ufo.speed * deltaTime;
          drawUFO(game.ufo.x, game.ufo.y);
          if (game.ufo.x > canvas.width + 100) {
            game.ufo = null;
          }
        }
      }

      // Draw the UFO
      function drawUFO(x, y) {
        ctx.save();
        ctx.translate(x, y);

        // Draw the base
        ctx.fillStyle = "silver";
        ctx.beginPath();
        ctx.ellipse(0, 0, 40, 10, 0, 0, 2 * Math.PI);
        ctx.fill();

        // Draw the dome
        ctx.fillStyle = "rgba(173, 216, 230, 0.7)";
        ctx.beginPath();
        ctx.arc(0, -5, 15, Math.PI, 0);
        ctx.fill();

        // Draw lights
        ctx.fillStyle = "yellow";
        for (let i = -20; i <= 20; i += 10) {
          ctx.beginPath();
          ctx.arc(i, 5, 3, 0, 2 * Math.PI);
          ctx.fill();
        }

        ctx.restore();
      }

      // Draw parallax background layers
      function drawParallaxBackground(deltaTime) {
        game.backgroundLayers.forEach((layer) => {
          layer.x -= layer.speed * deltaTime;
          if (layer.x <= -canvas.width) {
            layer.x = 0;
          }
          layer.draw(layer.x);
          layer.draw(layer.x + canvas.width);
        });
      }

      // Background layer 1 (farthest)
      function drawBackgroundLayer1(x) {
        ctx.fillStyle = "#7ec850"; // Default color
        const currentBackground = getCurrentBackground();
        if (currentBackground.type === "night") {
          ctx.fillStyle = "#013220";
        } else if (currentBackground.type === "sunrise") {
          ctx.fillStyle = "#DAA520";
        }
        ctx.beginPath();
        ctx.moveTo(x, canvas.height - game.groundHeight - 100);
        ctx.quadraticCurveTo(
          x + canvas.width / 4,
          canvas.height - game.groundHeight - 150,
          x + canvas.width / 2,
          canvas.height - game.groundHeight - 100
        );
        ctx.quadraticCurveTo(
          x + (canvas.width * 3) / 4,
          canvas.height - game.groundHeight - 50,
          x + canvas.width,
          canvas.height - game.groundHeight - 100
        );
        ctx.lineTo(x + canvas.width, canvas.height - game.groundHeight);
        ctx.lineTo(x, canvas.height - game.groundHeight);
        ctx.closePath();
        ctx.fill();
      }

      // Background layer 2 (closer)
      function drawBackgroundLayer2(x) {
        ctx.fillStyle = "#4caf50"; // Default color
        const currentBackground = getCurrentBackground();
        if (currentBackground.type === "night") {
          ctx.fillStyle = "#015f28";
        } else if (currentBackground.type === "sunrise") {
          ctx.fillStyle = "#B8860B";
        }
        ctx.beginPath();
        ctx.moveTo(x, canvas.height - game.groundHeight - 50);
        ctx.quadraticCurveTo(
          x + canvas.width / 4,
          canvas.height - game.groundHeight - 100,
          x + canvas.width / 2,
          canvas.height - game.groundHeight - 50
        );
        ctx.quadraticCurveTo(
          x + (canvas.width * 3) / 4,
          canvas.height - game.groundHeight,
          x + canvas.width,
          canvas.height - game.groundHeight - 50
        );
        ctx.lineTo(x + canvas.width, canvas.height - game.groundHeight);
        ctx.lineTo(x, canvas.height - game.groundHeight);
        ctx.closePath();
        ctx.fill();
      }

      // Draw the ground
      function drawGround(deltaTime) {
        game.groundX -= 200 * deltaTime; // Adjusted speed
        if (game.groundX <= -canvas.width) {
          game.groundX = 0;
        }
        ctx.fillStyle = "#8B4513"; // Brown color for ground
        ctx.fillRect(
          game.groundX,
          canvas.height - game.groundHeight,
          canvas.width,
          game.groundHeight
        );
        ctx.fillRect(
          game.groundX + canvas.width,
          canvas.height - game.groundHeight,
          canvas.width,
          game.groundHeight
        );
      }

      // Add a cloud
      function addCloud() {
        let cloud = {
          x: canvas.width,
          y: (Math.random() * canvas.height) / 2,
          width: canvas.width * 0.15,
          height: canvas.height * 0.08,
          speed: Math.random() * 20 + 20, // Adjusted speed
        };
        game.clouds.push(cloud);
      }

      // Draw clouds
      function drawClouds(deltaTime) {
        const currentBackground = getCurrentBackground();
        if (currentBackground.type === "night") return; // No clouds at night

        ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
        for (let i = 0; i < game.clouds.length; i++) {
          let cloud = game.clouds[i];
          cloud.x -= cloud.speed * deltaTime;
          if (cloud.x + cloud.width < 0) {
            game.clouds.splice(i, 1);
            i--;
            continue;
          }
          drawCloud(cloud.x, cloud.y, cloud.width, cloud.height);
        }
      }

      // Draw a single cloud
      function drawCloud(x, y, width, height) {
        ctx.beginPath();
        ctx.arc(
          x + width * 0.2,
          y + height * 0.5,
          height * 0.4,
          Math.PI * 0.5,
          Math.PI * 1.5
        );
        ctx.arc(
          x + width * 0.5,
          y + height * 0.3,
          height * 0.5,
          Math.PI * 1,
          Math.PI * 1.85
        );
        ctx.arc(
          x + width * 0.8,
          y + height * 0.5,
          height * 0.4,
          Math.PI * 1.5,
          Math.PI * 0.5
        );
        ctx.closePath();
        ctx.fill();
      }

      // Add ground creatures based on score
      function addGroundCreatures() {
        // Add frog at score 5 if not already added
        if (game.score >= 5 && !game.frogAdded) {
          let creature = {
            x: Math.random() * canvas.width * 0.8 + canvas.width * 0.1,
            y: canvas.height - game.groundHeight,
            width: canvas.width * 0.05,
            height: canvas.width * 0.05,
            speed: 50 + Math.random() * 50,
            type: "frog",
            direction: Math.random() < 0.5 ? 1 : -1,
            legPhase: 0,
            ribbitTimer: 0,
            jumpTimer: 0,
          };
          game.groundCreatures.push(creature);
          game.frogAdded = true;
        }

        // Add cat at score 10 if not already added
        if (game.score >= 10 && !game.catAdded) {
          let creature = {
            x: Math.random() * canvas.width * 0.8 + canvas.width * 0.1,
            y: canvas.height - game.groundHeight,
            width: canvas.width * 0.05,
            height: canvas.width * 0.05,
            speed: 50 + Math.random() * 50,
            type: "cat",
            direction: Math.random() < 0.5 ? 1 : -1,
            legPhase: 0,
            meowTimer: 0,
          };
          game.groundCreatures.push(creature);
          game.catAdded = true;
        }
      }

      // Update and draw ground creatures
      function updateGroundCreatures(deltaTime) {
        for (let i = 0; i < game.groundCreatures.length; i++) {
          const creature = game.groundCreatures[i];

          // Move creatures independently
          creature.x += creature.speed * creature.direction * deltaTime;

          // Simple walking or hopping animation
          creature.legPhase += 4 * deltaTime;
          if (creature.legPhase > Math.PI * 2) {
            creature.legPhase = 0;
          }

          // Turn around at edges
          if (creature.x <= 0 || creature.x + creature.width >= canvas.width) {
            creature.direction *= -1;
          }

          if (creature.type === "frog") {
            // High jump occasionally (once every 3-8 pipes)
            if (
              creature.jumpTimer <= 0 &&
              Math.random() < 1 / ((3 + Math.random() * 5) * 60)
            ) {
              creature.jumpTimer = 60; // Jump lasts for 1 second
            } else if (creature.jumpTimer > 0) {
              creature.jumpTimer--;
            }

            // Bounce frogs
            if (creature.jumpTimer > 0) {
              // High jump
              creature.y =
                canvas.height -
                game.groundHeight -
                Math.abs(Math.sin(creature.legPhase) * canvas.height * 0.5);
            } else {
              // Normal hopping
              creature.y =
                canvas.height -
                game.groundHeight -
                Math.abs(Math.sin(creature.legPhase) * 20);
            }

            // Rarely display "Ribbit"
            if (creature.ribbitTimer <= 0 && Math.random() < 0.001666) {
              creature.ribbitTimer = 60; // Show "Ribbit" for 1 second
            } else if (creature.ribbitTimer > 0) {
              creature.ribbitTimer--;
            }
          } else if (creature.type === "cat") {
            // Rarely display "Meow"
            if (creature.meowTimer <= 0 && Math.random() < 0.001666) {
              creature.meowTimer = 60; // Show "Meow" for 1 second
            } else if (creature.meowTimer > 0) {
              creature.meowTimer--;
            }
          }

          drawGroundCreature(creature);
        }
      }

      // Draw a ground creature
      function drawGroundCreature(creature) {
        ctx.save();
        ctx.translate(creature.x, creature.y - creature.height);

        // Flip creature based on direction
        if (creature.direction === -1) {
          ctx.scale(-1, 1);
          ctx.translate(-creature.width, 0);
        }

        if (creature.type === "cat") {
          // Draw cat body
          ctx.fillStyle = "black";
          ctx.fillRect(0, 0, creature.width, creature.height);

          // Draw legs (simple animation)
          ctx.fillRect(
            creature.width * 0.2,
            creature.height,
            creature.width * 0.1,
            Math.sin(creature.legPhase) * 5 + 10
          );
          ctx.fillRect(
            creature.width * 0.7,
            creature.height,
            creature.width * 0.1,
            -Math.sin(creature.legPhase) * 5 + 10
          );

          // Draw ears
          ctx.beginPath();
          ctx.moveTo(creature.width * 0.2, 0);
          ctx.lineTo(creature.width * 0.3, -creature.height * 0.2);
          ctx.lineTo(creature.width * 0.4, 0);
          ctx.fill();

          ctx.beginPath();
          ctx.moveTo(creature.width * 0.6, 0);
          ctx.lineTo(creature.width * 0.7, -creature.height * 0.2);
          ctx.lineTo(creature.width * 0.8, 0);
          ctx.fill();

          // Draw eyes
          ctx.fillStyle = "white";
          ctx.fillRect(
            creature.width * 0.3,
            creature.height * 0.2,
            creature.width * 0.1,
            creature.height * 0.1
          );
          ctx.fillRect(
            creature.width * 0.6,
            creature.height * 0.2,
            creature.width * 0.1,
            creature.height * 0.1
          );

          // Draw "Meow" if timer is active
          if (creature.meowTimer > 0) {
            ctx.fillStyle = "white";
            ctx.font = `${creature.width * 0.5}px Arial`;
            ctx.fillText("Meow", creature.width * 0.5, -creature.height * 0.5);
          }
        } else if (creature.type === "frog") {
          // Draw frog body
          ctx.fillStyle = "green";
          ctx.beginPath();
          ctx.ellipse(
            creature.width / 2,
            creature.height / 2,
            creature.width / 2,
            creature.height / 2,
            0,
            0,
            2 * Math.PI
          );
          ctx.fill();

          // Draw legs (simple hopping animation)
          ctx.fillStyle = "darkgreen";
          ctx.beginPath();
          ctx.moveTo(creature.width * 0.2, creature.height * 0.8);
          ctx.lineTo(creature.width * 0.2, creature.height);
          ctx.lineTo(creature.width * 0.4, creature.height * 0.8);
          ctx.fill();

          ctx.beginPath();
          ctx.moveTo(creature.width * 0.8, creature.height * 0.8);
          ctx.lineTo(creature.width * 0.8, creature.height);
          ctx.lineTo(creature.width * 0.6, creature.height * 0.8);
          ctx.fill();

          // Draw eyes
          ctx.fillStyle = "white";
          ctx.beginPath();
          ctx.arc(
            creature.width * 0.3,
            creature.height * 0.2,
            creature.width * 0.1,
            0,
            2 * Math.PI
          );
          ctx.fill();
          ctx.beginPath();
          ctx.arc(
            creature.width * 0.7,
            creature.height * 0.2,
            creature.width * 0.1,
            0,
            2 * Math.PI
          );
          ctx.fill();

          ctx.fillStyle = "black";
          ctx.beginPath();
          ctx.arc(
            creature.width * 0.3,
            creature.height * 0.2,
            creature.width * 0.05,
            0,
            2 * Math.PI
          );
          ctx.fill();
          ctx.beginPath();
          ctx.arc(
            creature.width * 0.7,
            creature.height * 0.2,
            creature.width * 0.05,
            0,
            2 * Math.PI
          );
          ctx.fill();

          // Draw "Ribbit" if timer is active
          if (creature.ribbitTimer > 0) {
            ctx.fillStyle = "white";
            ctx.font = `${creature.width * 0.5}px Arial`;
            ctx.fillText(
              "Ribbit",
              creature.width * 0.5,
              -creature.height * 0.5
            );
          }
        }

        ctx.restore();
      }

      // Draw the bird
      function drawBird() {
        ctx.save();
        ctx.translate(game.bird.x, game.bird.y);
        ctx.rotate(game.bird.angle);

        // Draw body
        ctx.fillStyle = "#00FFFF"; // Cyan for better visibility
        ctx.beginPath();
        ctx.ellipse(
          0,
          0,
          game.bird.width / 2,
          game.bird.height / 2,
          0,
          0,
          2 * Math.PI
        );
        ctx.fill();
        ctx.strokeStyle = "black"; // Outline for better contrast
        ctx.lineWidth = 2;
        ctx.stroke();

        // Draw wing
        ctx.save();
        ctx.translate(-game.bird.width * 0.1, 0);
        ctx.rotate(game.wingAngle);
        ctx.fillStyle = "#00CED1"; // Darker Cyan for wing
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.quadraticCurveTo(
          -game.bird.width * 0.3,
          -game.bird.height * 0.1,
          0,
          -game.bird.height * 0.4
        );
        ctx.quadraticCurveTo(
          game.bird.width * 0.2,
          -game.bird.height * 0.1,
          0,
          0
        );
        ctx.closePath();
        ctx.fill();
        ctx.restore();

        // Draw the bird's eye
        ctx.fillStyle = "black";
        ctx.beginPath();
        ctx.arc(
          game.bird.width / 8,
          -game.bird.height / 8,
          game.bird.width / 20,
          0,
          2 * Math.PI
        );
        ctx.fill();

        // Draw the bird's beak
        ctx.fillStyle = "orange";
        ctx.beginPath();
        ctx.moveTo(game.bird.width / 2, 0);
        ctx.lineTo(
          game.bird.width / 2 + game.bird.width * 0.1,
          -game.bird.height * 0.1
        );
        ctx.lineTo(
          game.bird.width / 2 + game.bird.width * 0.1,
          game.bird.height * 0.1
        );
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }

      // Create particles when bird flaps
      function createParticles() {
        for (let i = 0; i < 10; i++) {
          game.particles.push({
            x: game.bird.x - game.bird.width / 2,
            y: game.bird.y,
            size: Math.random() * 5 + 2,
            speedX: -Math.random() * 100 - 50,
            speedY: (Math.random() - 0.5) * 100,
            color: `hsl(${Math.random() * 360}, 100%, 50%)`,
            life: 1, // in seconds
          });
        }
      }

      // Update and draw particles
      function updateParticles(deltaTime) {
        for (let i = 0; i < game.particles.length; i++) {
          const particle = game.particles[i];
          particle.x += particle.speedX * deltaTime;
          particle.y += particle.speedY * deltaTime;
          particle.life -= deltaTime;
          if (particle.life <= 0) {
            game.particles.splice(i, 1);
            i--;
            continue;
          }
          ctx.fillStyle = particle.color;
          ctx.beginPath();
          ctx.arc(particle.x, particle.y, particle.size, 0, 2 * Math.PI);
          ctx.fill();
        }
      }

      // Update and draw pipes
      function updatePipes(deltaTime) {
        let now = Date.now();
        // Add new pipes
        if (now - game.lastPipeTime > game.pipeInterval) {
          const gapPosition =
            Math.floor(
              Math.random() *
                (canvas.height -
                  game.pipeGap -
                  game.groundHeight -
                  canvas.height * 0.2)
            ) +
            canvas.height * 0.1;
          const topPipe = {
            x: canvas.width,
            y: 0,
            width: game.pipeWidth,
            height: gapPosition,
            passed: false,
            isTop: true,
          };
          const bottomPipe = {
            x: canvas.width,
            y: gapPosition + game.pipeGap,
            width: game.pipeWidth,
            height:
              canvas.height - (gapPosition + game.pipeGap) - game.groundHeight,
            passed: false,
            isTop: false,
          };
          game.pipes.push(topPipe);
          game.pipes.push(bottomPipe);
          game.lastPipeTime = now;
        }

        // Move and draw pipes
        for (let i = 0; i < game.pipes.length; i++) {
          const pipe = game.pipes[i];
          pipe.x -= game.pipeSpeed * deltaTime;
          if (pipe.x + pipe.width < 0) {
            game.pipes.splice(i, 1);
            i--;
            continue;
          }
          drawPipe(pipe);
          // Increase score when passing the top pipe only
          if (!pipe.passed && pipe.x + pipe.width < game.bird.x && pipe.isTop) {
            game.score++;
            pipe.passed = true;
            if (game.score > game.highScore) {
              game.highScore = game.score;
              localStorage.setItem("highScore", game.highScore);
            }
          }
        }
      }

      // Draw a single pipe
      function drawPipe(pipe) {
        // Create gradient for pipe body
        const gradient = ctx.createLinearGradient(
          pipe.x,
          0,
          pipe.x + pipe.width,
          0
        );
        gradient.addColorStop(0, "#228B22");
        gradient.addColorStop(1, "#006400");
        ctx.fillStyle = gradient;
        // Draw pipe body
        ctx.fillRect(pipe.x, pipe.y, pipe.width, pipe.height);
        // Draw pipe lip
        const pipeLipHeight = pipe.width * 0.15;
        ctx.fillStyle = "#2E8B57";
        ctx.fillRect(
          pipe.x - pipe.width * 0.1,
          pipe.isTop ? pipe.height - pipeLipHeight : pipe.y,
          pipe.width * 1.2,
          pipeLipHeight
        );
        // Outline for the pipe lip
        ctx.strokeStyle = "black";
        ctx.lineWidth = 2;
        ctx.strokeRect(
          pipe.x - pipe.width * 0.1,
          pipe.isTop ? pipe.height - pipeLipHeight : pipe.y,
          pipe.width * 1.2,
          pipeLipHeight
        );
        // Add shading to the pipe lip
        ctx.fillStyle = "rgba(0, 0, 0, 0.1)";
        ctx.fillRect(
          pipe.x - pipe.width * 0.1,
          pipe.isTop ? pipe.height - pipeLipHeight : pipe.y,
          pipe.width * 1.2,
          pipeLipHeight / 2
        );
      }

      // Check for collisions
      function checkCollisions() {
        // Ground collision
        if (
          game.bird.y + game.bird.height / 2 >=
            canvas.height - game.groundHeight ||
          game.bird.y - game.bird.height / 2 <= 0
        ) {
          game.isGameOver = true;
        }

        // Pipe collisions
        for (let i = 0; i < game.pipes.length; i++) {
          const pipe = game.pipes[i];
          if (
            game.bird.x + game.bird.width / 2 > pipe.x &&
            game.bird.x - game.bird.width / 2 < pipe.x + pipe.width &&
            game.bird.y + game.bird.height / 2 > pipe.y &&
            game.bird.y - game.bird.height / 2 < pipe.y + pipe.height
          ) {
            game.isGameOver = true;
            break;
          }
        }
      }

      // Increase game difficulty over time
      function increaseDifficulty() {
        // Decrease pipe gap size after 10 and 20 points
        if (
          (game.score === 10 || game.score === 20) &&
          game.pipeGapIndex < game.pipeGapSizes.length - 1
        ) {
          game.pipeGapIndex++;
          game.pipeGap = game.pipeGapSizes[game.pipeGapIndex];
        }

        // Increase pipe speed every 10 points
        if (
          game.score > 0 &&
          game.score % 10 === 0 &&
          game.pipeSpeed < game.maxPipeSpeed
        ) {
          game.pipeSpeed += 5; // Increase speed by 10
        }
      }

      // Draw the intro screen
      function drawIntroScreen() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        // Draw background
        drawBackground(1 / 60);
        drawParallaxBackground(1 / 60);
        drawClouds(1 / 60);
        drawGround(1 / 60);

        // Draw "NOOTY BIRD" title
        ctx.fillStyle = "white";
        ctx.font = `bold ${canvas.width * 0.1}px Arial`;
        ctx.textAlign = "center";
        ctx.fillText(
          "NOOTY BIRD",
          canvas.width / 2,
          canvas.height / 2 - canvas.height * 0.1
        );

        // Draw instructions
        ctx.font = `bold ${canvas.width * 0.03}px Arial`;
        ctx.fillText(
          "Press SPACE or TAP to Start",
          canvas.width / 2,
          canvas.height / 2 + canvas.height * 0.05
        );
      }

      // Draw the Game Over screen
      function drawGameOverScreen() {
        ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "white";
        ctx.font = `bold ${canvas.width * 0.05}px Arial`;
        ctx.textAlign = "center";
        ctx.fillText(
          "Game Over",
          canvas.width / 2,
          canvas.height / 2 - canvas.height * 0.1
        );
        ctx.font = `bold ${canvas.width * 0.03}px Arial`;
        ctx.fillText(
          `Your Score: ${game.score}`,
          canvas.width / 2,
          canvas.height / 2
        );
        if (game.score >= game.highScore) {
          ctx.fillText(
            "ðŸŽ‰ Congratulations! New High Score! ðŸŽ‰",
            canvas.width / 2,
            canvas.height / 2 + canvas.height * 0.05
          );
        }
        ctx.fillText(
          "Press SPACE or TAP to Restart",
          canvas.width / 2,
          canvas.height / 2 + canvas.height * 0.1
        );
      }

      // Draw the pause screen
      function drawPauseScreen() {
        ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "white";
        ctx.font = `bold ${canvas.width * 0.05}px Arial`;
        ctx.textAlign = "center";
        ctx.fillText("Paused", canvas.width / 2, canvas.height / 2);
      }

      // Start the game by displaying the intro screen
      resetGame();
    </script>
  </body>
</html>
